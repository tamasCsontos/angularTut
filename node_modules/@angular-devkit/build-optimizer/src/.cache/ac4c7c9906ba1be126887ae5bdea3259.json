{"remainingRequest":"/home/csonti/Desktop/angular/project/optimizations-final/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/csonti/Desktop/angular/project/optimizations-final/node_modules/@firebase/messaging/dist/esm/src/controllers/controller-interface.js","dependencies":[{"path":"/home/csonti/Desktop/angular/project/optimizations-final/node_modules/@firebase/messaging/dist/esm/src/controllers/controller-interface.js","mtime":1522361122000},{"path":"/home/csonti/Desktop/angular/project/optimizations-final/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/csonti/Desktop/angular/project/optimizations-final/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nimport * as tslib_1 from \"tslib\";\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from '../models/errors';\nimport TokenDetailsModel from '../models/token-details-model';\nimport VapidDetailsModel from '../models/vapid-details-model';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport IIDModel from '../models/iid-model';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nvar SENDER_ID_OPTION_NAME = 'messagingSenderId';\n// Database cache should be invalidated once a week.\nexport var TOKEN_EXPIRATION_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days\nvar ControllerInterface = /** @class */ /*@__PURE__*/ (function () {\n    /**\n     * An interface of the Messaging Service API\n     * @param {!firebase.app.App} app\n     */\n    function ControllerInterface(app) {\n        var _this = this;\n        this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n        if (!app.options[SENDER_ID_OPTION_NAME] ||\n            typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n            throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n        }\n        this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n        this.tokenDetailsModel_ = new TokenDetailsModel();\n        this.vapidDetailsModel_ = new VapidDetailsModel();\n        this.iidModel_ = new IIDModel();\n        this.app = app;\n        this.INTERNAL = {};\n        this.INTERNAL.delete = function () { return _this.delete(); };\n    }\n    /**\n     * @export\n     */\n    ControllerInterface.prototype.getToken = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var currentPermission, swReg, publicVapidKey, pushSubscription, tokenDetails;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        currentPermission = this.getNotificationPermission_();\n                        if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n                            if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n                                return [2 /*return*/, Promise.reject(this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED))];\n                            }\n                            // We must wait for permission to be granted\n                            return [2 /*return*/, Promise.resolve(null)];\n                        }\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 1:\n                        swReg = _a.sent();\n                        return [4 /*yield*/, this.getPublicVapidKey_()];\n                    case 2:\n                        publicVapidKey = _a.sent();\n                        return [4 /*yield*/, this.getPushSubscription(swReg, publicVapidKey)];\n                    case 3:\n                        pushSubscription = _a.sent();\n                        return [4 /*yield*/, this.tokenDetailsModel_.getTokenDetailsFromSWScope(swReg.scope)];\n                    case 4:\n                        tokenDetails = _a.sent();\n                        if (tokenDetails) {\n                            return [2 /*return*/, this.manageExistingToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n                        }\n                        return [2 /*return*/, this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n                }\n            });\n        });\n    };\n    /**\n     * manageExistingToken is triggered if there's an existing FCM token in the\n     * database and it can take 3 different actions:\n     * 1) Retrieve the existing FCM token from the database.\n     * 2) If VAPID details have changed: Delete the existing token and create a\n     * new one with the new VAPID key.\n     * 3) If the database cache is invalidated: Send a request to FCM to update\n     * the token, and to check if the token is still valid on FCM-side.\n     */\n    ControllerInterface.prototype.manageExistingToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var isTokenValid, now;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        isTokenValid = this.isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails);\n                        if (isTokenValid) {\n                            now = Date.now();\n                            if (now < tokenDetails['createTime'] + TOKEN_EXPIRATION_MILLIS) {\n                                return [2 /*return*/, tokenDetails['fcmToken']];\n                            }\n                            else {\n                                return [2 /*return*/, this.updateToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n                            }\n                        }\n                        // If the token is no longer valid (for example if the VAPID details\n                        // have changed), delete the existing token, and create a new one.\n                        return [4 /*yield*/, this.deleteToken(tokenDetails['fcmToken'])];\n                    case 1:\n                        // If the token is no longer valid (for example if the VAPID details\n                        // have changed), delete the existing token, and create a new one.\n                        _a.sent();\n                        return [2 /*return*/, this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n                }\n            });\n        });\n    };\n    /*\n     * Checks if the tokenDetails match the details provided in the clients.\n     */\n    ControllerInterface.prototype.isTokenStillValid = function (pushSubscription, publicVapidKey, tokenDetails) {\n        if (arrayBufferToBase64(publicVapidKey) !== tokenDetails['vapidKey']) {\n            return false;\n        }\n        // getKey() isn't defined in the PushSubscription externs file, hence\n        // subscription['getKey']('<key name>').\n        return (pushSubscription.endpoint === tokenDetails['endpoint'] &&\n            arrayBufferToBase64(pushSubscription['getKey']('auth')) ===\n                tokenDetails['auth'] &&\n            arrayBufferToBase64(pushSubscription['getKey']('p256dh')) ===\n                tokenDetails['p256dh']);\n    };\n    ControllerInterface.prototype.updateToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var updatedToken, allDetails, e_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 4, , 6]);\n                        return [4 /*yield*/, this.iidModel_.updateToken(this.messagingSenderId_, tokenDetails['fcmToken'], tokenDetails['fcmPushSet'], pushSubscription, publicVapidKey)];\n                    case 1:\n                        updatedToken = _a.sent();\n                        allDetails = {\n                            swScope: swReg.scope,\n                            vapidKey: publicVapidKey,\n                            subscription: pushSubscription,\n                            fcmSenderId: this.messagingSenderId_,\n                            fcmToken: updatedToken,\n                            fcmPushSet: tokenDetails['fcmPushSet']\n                        };\n                        return [4 /*yield*/, this.tokenDetailsModel_.saveTokenDetails(allDetails)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.vapidDetailsModel_.saveVapidDetails(swReg.scope, publicVapidKey)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, updatedToken];\n                    case 4:\n                        e_1 = _a.sent();\n                        return [4 /*yield*/, this.deleteToken(tokenDetails['fcmToken'])];\n                    case 5:\n                        _a.sent();\n                        throw e_1;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ControllerInterface.prototype.getNewToken = function (swReg, pushSubscription, publicVapidKey) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var tokenDetails, allDetails;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.iidModel_.getToken(this.messagingSenderId_, pushSubscription, publicVapidKey)];\n                    case 1:\n                        tokenDetails = _a.sent();\n                        allDetails = {\n                            swScope: swReg.scope,\n                            vapidKey: publicVapidKey,\n                            subscription: pushSubscription,\n                            fcmSenderId: this.messagingSenderId_,\n                            fcmToken: tokenDetails['token'],\n                            fcmPushSet: tokenDetails['pushSet']\n                        };\n                        return [4 /*yield*/, this.tokenDetailsModel_.saveTokenDetails(allDetails)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.vapidDetailsModel_.saveVapidDetails(swReg.scope, publicVapidKey)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, tokenDetails['token']];\n                }\n            });\n        });\n    };\n    /**\n     * This method deletes tokens that the token manager looks after,\n     * unsubscribes the token from FCM  and then unregisters the push\n     * subscription if it exists. It returns a promise that indicates\n     * whether or not the unsubscribe request was processed successfully.\n     * @export\n     */\n    ControllerInterface.prototype.deleteToken = function (token) {\n        var _this = this;\n        return this.tokenDetailsModel_\n            .deleteToken(token)\n            .then(function (details) {\n            return _this.iidModel_.deleteToken(details['fcmSenderId'], details['fcmToken'], details['fcmPushSet']);\n        })\n            .then(function () {\n            return _this.getSWRegistration_()\n                .then(function (registration) {\n                if (registration) {\n                    return registration.pushManager.getSubscription();\n                }\n            })\n                .then(function (subscription) {\n                if (subscription) {\n                    return subscription.unsubscribe();\n                }\n            });\n        });\n    };\n    ControllerInterface.prototype.getSWRegistration_ = function () {\n        throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n    };\n    ControllerInterface.prototype.getPublicVapidKey_ = function () {\n        throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n    };\n    //\n    // The following methods should only be available in the window.\n    //\n    ControllerInterface.prototype.requestPermission = function () {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\n     * Gets a PushSubscription for the current user.\n     */\n    ControllerInterface.prototype.getPushSubscription = function (swRegistration, publicVapidKey) {\n        return swRegistration.pushManager.getSubscription().then(function (subscription) {\n            if (subscription) {\n                return subscription;\n            }\n            return swRegistration.pushManager.subscribe({\n                userVisibleOnly: true,\n                applicationServerKey: publicVapidKey\n            });\n        });\n    };\n    /**\n     * @export\n     * @param {!ServiceWorkerRegistration} registration\n     */\n    ControllerInterface.prototype.useServiceWorker = function (registration) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\n     * @export\n     * @param {!string} b64PublicKey\n     */\n    ControllerInterface.prototype.usePublicVapidKey = function (b64PublicKey) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\n     * @export\n     * @param {!firebase.Observer|function(*)} nextOrObserver\n     * @param {function(!Error)=} optError\n     * @param {function()=} optCompleted\n     * @return {!function()}\n     */\n    ControllerInterface.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    /**\n     * @export\n     * @param {!firebase.Observer|function()} nextOrObserver An observer object\n     * or a function triggered on token refresh.\n     * @param {function(!Error)=} optError Optional A function\n     * triggered on token refresh error.\n     * @param {function()=} optCompleted Optional function triggered when the\n     * observer is removed.\n     * @return {!function()} The unsubscribe function for the observer.\n     */\n    ControllerInterface.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n    };\n    //\n    // The following methods are used by the service worker only.\n    //\n    /**\n     * @export\n     * @param {function(Object)} callback\n     */\n    ControllerInterface.prototype.setBackgroundMessageHandler = function (callback) {\n        throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n    };\n    //\n    // The following methods are used by the service themselves and not exposed\n    // publicly or not expected to be used by developers.\n    //\n    /**\n     * This method is required to adhere to the Firebase interface.\n     * It closes any currently open indexdb database connections.\n     */\n    ControllerInterface.prototype.delete = function () {\n        return Promise.all([\n            this.tokenDetailsModel_.closeDatabase(),\n            this.vapidDetailsModel_.closeDatabase()\n        ]);\n    };\n    /**\n     * Returns the current Notification Permission state.\n     * @private\n     * @return {string} The currenct permission state.\n     */\n    ControllerInterface.prototype.getNotificationPermission_ = function () {\n        return Notification.permission;\n    };\n    ControllerInterface.prototype.getTokenDetailsModel = function () {\n        return this.tokenDetailsModel_;\n    };\n    ControllerInterface.prototype.getVapidDetailsModel = function () {\n        return this.vapidDetailsModel_;\n    };\n    /**\n     * @protected\n     * @returns {IIDModel}\n     */\n    ControllerInterface.prototype.getIIDModel = function () {\n        return this.iidModel_;\n    };\n    return ControllerInterface;\n}());\nexport default ControllerInterface;\n",null]}